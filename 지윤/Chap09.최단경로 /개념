# 가장 빠르게 도달하는 방법

최단경로 = 가장 짧은 경로를 찾는 알고리즘

- 상황에 맞는 효율적인 알고리즘이 이미 정립됨
    - 1) 한 지점에서 다른 특정 지점까지의 최단 경로
    - 2) 모든 지점에서 다른 모든 지점까지의 최단 경로
- 최단 경로 문제는 보통 그래프를 이용해서 표현
- 다익스트라, 플로이드, 벨만 포드

# 다익스트라 최단 경로 알고리즘

- 그래프에서 여러 개의 노드가 있을 때, `특정한 노드`에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구함
- “음의 간선”이 없을 때 정상적으로 동작
- 기본적으로 그리디 알고리즘으로 분류 → 매번 가장 비용이 적은 노드를 선택해서 반복
- 원리
    - 1) 출발 노드를 설정한다.
    - 2) 최단 거리 테이블을 초기화한다.
    - 3) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
    - 4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
- 각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트에 저장함
    - 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한다.

⇒ 나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 그것을 제일 짧은 경로로 처리한다. → 그리디 알고리즘으로 볼 수 있다.

## 구현 방법

1) 구현하기 쉽지만 느리게 동작하는 코드

2) 구현하기에 조금 더 까다롭지만 빠르게 동작하는 코드

- 초기 상태에서는 다른 모든 노드로 가는 최단 거리를 “무한”으로 초기화한다
    - 무한 = int(1e9)
- 한 번 최단 거리로 선택된 노드는 최단 거리가 감소하지 않는다.
    - 한단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 진행이다.
    - 그렇기 때문에 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없다.

### 방법 1. 간단한 다익스트라 알고리즘

- 시간복잡도 = O(n^2)
    - 현재 노드와 연결된 노드를 매번 일일히 확인해야함 → 10000개 넘어간다면 힘듦 → 개선된 알고리즘 필요
- 각 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인한다. (순차 탐색)
- 모든 리스트를 (노드 개수 + 1)의 크기로 할당하여 노드의 번호를 인덱스로 하여 바로 리스트에 접근할 수 있도록 한다.